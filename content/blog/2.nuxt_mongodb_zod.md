---
title: 'Guide : MongoDB et Zod dans une application Nuxt.js'
description: "Une approche sans ORM pour intégrer MongoDB dans une application Nuxt.js"
publishedAt: '2024-02-17'
icon: 'heroicons:code-bracket'
sitemap:
  lastmod: '2024-02-17'
  changefreq: monthly
  priority: 0.8
---

Bonjour à tous,

Aujourd'hui je vais vous présenter une façon de connecter votre application Nuxt à une base de données MongoDB et à valider les données entrantes avec Zod. Cette technique permet de se passer d'un ORM tel que mongoose pour gagner en performance et en flexibilité et de partager vos validations entre le front et le back, ouvrant ainsi la possibilité d'effectuer des validations coté client.

## 1. Prérequis
Il vous faudra déjà avoir une application Nuxt 3 en place ainsi qu'un serveur MongoDB sur votre machine. Pour en créer une nouvelle, je vous invite a suivre le [Get started](https://nuxt.com/docs/getting-started/installation) officiel. Dans ce guide nous utiliserons également Typescript mais vous devriez pouvoir convertir le code en Javascript sans difficultés.

Nous allons ensuite installer les dépendances nécessaires :
```bash
pnpm add mongodb zod
```

## 2. Connexion à la base de données
Pour persister notre client MongoDB, nous allons créer une classe `DBClient` :
```ts [~/db/client.ts]
import { MongoClient } from 'mongodb'

export class DBClient {
  static mongoClient: MongoClient

  static async connect(url: string) {
    if (this.mongoClient) return

    this.mongoClient = new MongoClient(url)
    await this.mongoClient.connect()
  }

  static get db() {
    if (!this.mongoClient) throw new Error('Mongo client not connected')
    return this.mongoClient.db()
  }
}
```

Il faut ensuite initialiser la connexion au démarrage de l'application. Pour ça nous allons utiliser un [plugin nitro](https://nitro.unjs.io/guide/plugins).

Attention : bien que le plugin décrit ci-dessous est asynchrone, il faut garder en tête que nitro n'en tiendra pas compte à l'initialisation. Ce qui veut dire que si vous ajoutez un autre plugin après celui ci, la connexion ne sera pas nécessairement résolue.
```ts [~/server/plugins/db.ts]
import { DBClient } from '~/db/client'

export default defineNitroPlugin(async () => {
  const config = useRuntimeConfig()
  try {
    await DBClient.connect(config.mongoUrl)

    console.log('[DB] connection established.')
  }
  catch (err) {
    console.error('[DB] connection failed.', err)
  }
})
```

Comme vous pouvez le voir, ce plugin utilise une clé de config runtime pour l'url de la DB. Ajoutons une valeur par défaut à cette config dans le fichier `nuxt.config.ts` :
```ts [~/nuxt.config.ts]
export default defineNuxtConfig({
  // ...
  runtimeConfig: {
    mongoUrl: 'mongodb://localhost:27017/demo'
  }
  // ...
})
```
Pour changer la valeur de la config en production par exemple, on pourra ajouter la variable d'environment `NUXT_MONGO_URL` au fichier `.env` ou à notre environment (cf [le guide sur les variables d'environment](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables)) :
``` [~/.env]
NUXT_MONGO_URL="mongodb://localhost:27017/production"
```


## 3. Modèle de données et repositories
Maintenant que notre application est prête à utiliser notre base de données MongoDB, nous allons pouvoir commencer à gérer nos modèles.
Pour gérer le schéma de nos données, nous allons utiliser la librairie de validation [Zod](https://zod.dev/) :
```ts [~/db/message.schema.ts]
import { z } from 'zod'

export const message = z.object({
  username: z.string().min(3, 'Doit être plus long que 3 caractères').max(20, 'Doit être plus court que 20 caractères').trim(),
  content: z.string().min(1, 'Doit être plus long que 1 caractères').max(140, 'Doit être plus court que 140 caractères').trim(),
  content: z.string().min(1),
})
export const messageDTO = z.object({ username: message.shape.username, content: message.shape.content }).strict()
export type MessageDTO = z.infer<typeof messageDTO>
```
Ce fichier exporte respectivement :
- le schéma qu'on utilisera pour définir un modèle de données.
- un schéma `Data Transfer Object` qui sera utilisé pour la validation des données entrées par l'utilisateur aussi bien coté client que coté serveur.
- Le type de notre `DTO` pour le typage Typescript.

Nous allons ensuite créer une classe de base pour définir certains comportement commun à tous nos modèles :
```ts [~/db/base.repo.ts]
import { ObjectId } from 'mongodb'
import { DBClient } from './client'

export interface BaseModel {
  _id: ObjectId
  id: string
  createdAt: Date
  updatedAt: Date
}

export class BaseRepository<Model extends BaseModel> {
  private collectionName: string

  constructor(collectionName: string) {
    this.collectionName = collectionName
  }

  get collection() {
    return DBClient.db.collection<Model>(this.collectionName)
  }

  initDocument(object: any) {
    const now = new Date()
    const _id = new ObjectId()

    return {
      _id,
      id: _id.toString(),
      createdAt: now,
      ...object,
    }
  }
}
```
Cette classe permet :
- d'accèder à la collection MongoDB correspondante avec le getter `.collection`.
- d'initialiser un nouveau document à partir de l'objet qu'on passe en paramètre de la fonction `.initDocument`.


On peut dorénavant créer notre repository pour gérer nos messages. Dans cet exemple très simple, nous aurons besoin de seulement 2 fonctions : une pour valider/créer un nouveau message, et une autre pour récupérer les 10 derniers messages pour les afficher dans l'application :
```ts [~/db/message.repo.ts]
import type { z } from 'zod'
import { type MessageDTO, type message, messageDTO } from './message.schema'
import { type BaseModel, BaseRepository } from './base.repo'

export type MessageModel = z.infer<typeof message> & BaseModel

export class MessageRepository extends BaseRepository<MessageModel> {
  constructor() {
    super('messages')
  }

  async create(dto: MessageDTO) {
    const candidate = messageDTO.parse(dto)
    const document = this.initDocument(candidate)
    await this.collection.insertOne(document)
    return document as MessageModel
  }

  async getRecent() {
    return await this.collection.find({}, { sort: { createdAt: -1 }, limit: 10 }).toArray()
  }
}
```

## 4. Formulaire et validation coté client
Voyons à présent comment profiter de notre schéma pour valider notre formulaire. Pour faire simple, nous allons tout implémenter dans le fichier `~/app.vue` :
```vue [~/app.vue]
<script setup lang="ts">
import { messageDTO } from './db/message.schema';

const formData = reactive({ username: '', content: '' })
const formErrors = reactive({ username: '', content: '' })
function onSubmit() {
  const result = messageDTO.safeParse(formData)
  if (!result.success) {
    const formattedError = result.error.format()
    formErrors.username = formattedError.username?._errors[0] || ''
    formErrors.content = formattedError.content?._errors[0] || ''

    return
  }
}
</script>

<template>
  <div>
    <form @submit.prevent="onSubmit">
      <div>
        <input v-model="formData.username" type="text" placeholder="Votre nom" />
        <p>{{ formErrors.username }}</p>
      </div>
      <div>
        <textarea v-model="formData.content" placeholder="Votre message" />
        <p>{{ formErrors.content }}</p>
      </div>
      <button type="submit">Envoyer</button>
    </form>
  </div>
</template>
```
Nous initialisons 2 objets réactifs : un pour stocker les valeurs des champs de notre formulaire, et un pour stocker les erreurs de validations.
Ensuite nous implémentons une fonction `onSubmit` qui va valider notre formulaire et qui l'enverra plus tard à notre API. Si des erreurs sont détectés, elles seront ajoutés à l'objet `formErrors`. Pour aller plus loin on pourrait utiliser soit une librairie externe capable d'utiliser un schéma zod (ex: [Nuxt UI](https://ui.nuxt.com/components/form#zod), [@formkit/zod](https://formkit.com/fr/plugins/zod)), soit implémenter un composable pour extraire la logique de validation et la rendre réutilisable mais restons simple pour ce guide !

## 5. API et validation coté serveur
À présent nous allons ajouter une route d'API qui va permettre de recevoir un nouveau message, de le valider et de le persisté en base de données :
```ts [~/server/api/messages/index.post.ts]
import { ZodError } from 'zod'
import { MessageRepository } from '~/db/message.repo'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody<{ username: string, content: string }>(event)
    const repo = new MessageRepository()
    const message = await repo.create(body)
    return { message }
  }
  catch (error) {
    if (error instanceof ZodError) {
      const formatedError = (error as ZodError).format()
      sendError(event, createError({ status: 422, data: formatedError }))
    }
    else {
      sendError(event, createError('Une erreur est survenue'))
    }
  }
})
```
En premier lieu, on lit le contenu du body de la requete, puis on le passe à la fonction `create` d'une instance de notre classe `MessageRepository`. Si le message est valide, on le renvoit en réponse, si non, l'erreur sera interceptée, formatée puis renvoyé au client.

Maintenant nous allons mettre à jour notre client pour implémenter un fetch vers cette nouvelle route:
```ts [~/app.vue]
function onSubmit() {
  // le reste du code

  $fetch('/api/messages', {
    method: 'POST',
    body: formData,
  })
    .then(() => {
      formErrors.username = ''
      formErrors.content = ''
      formData.username = ''
      formData.content = ''
    }).catch((err) => {
      if (err.data) {
        formErrors.username = err.data.data.username?._errors[0] || ''
        formErrors.content = err.data.data.content?._errors[0] || ''
      }
      else {
        console.error(err)
      }
    })
}
```
Si la rêquete réussis, on réinitialise les erreurs et on vide les champs du formulaire, si non, on récupère le contenu de l'erreur et on affiche les messages de validations dans les champs correspondants.

## 6. Récupération de nos messages
Ce guide à couvert l'essentiel de l'architecture que je voulais vous presentez, mais allons au bout des choses ! On va donc implémenter une route d'API pour récuperer les messages :
```ts [~/server/api/messages/index.ts]
import { MessageRepository } from "~/db/message.repo"

export default defineEventHandler(async () => {
  const repo = new MessageRepository()
  const messages = await repo.getRecent()

  return { messages }
})
```

Et maintenant on met à jour le client :
```vue [~/app.vue]
<script setup lang="ts">
// ...
const { data, refresh } = await useFetch('/api/messages')
// ...

function onSubmit() {
  // ...

  $fetch('/api/messages', {
    method: 'POST',
    body: formData,
  })
    .then(() => {
      formData.username = ''
      formData.content = ''
      refresh()
    })
    // ...
}
</script>

<template>
  <div>
    <!-- ... -->
    <div v-for="message in data.messages">
      <p>{{ message.username }} :<br>{{ message.content }}</p>
    </div>
  </div>
</template>

```

## Conclusion
Dans ce guide nous avons vu ensemble comment intégrer une base de données MongoDB à une application Nuxt.js ainsi que de gérer nos schémas et nos validations à l'aide de Zod.
L'avantage de cette architecture est qu'elle permet de facilement encapsuler notre logique métier dans des "repositories" et d'avoir un code très expressif. Nous avons également une maitrise complête de la manière avec laquelle on intéragi avec la base de données sans la lourdeur et la complexité que peuvent apporter certains ORM. Aussi, nous avons à notre disposition des schémas de validations très complete qui nous permet de typer totalement nos données sans génération de code.
Celà dit, en l'absence d'un ORM, nous sommes livrés à nous même en terme de conventions

Retrouvez le projet de démo sur [GitHub](https://github.com/pedraal/...)
