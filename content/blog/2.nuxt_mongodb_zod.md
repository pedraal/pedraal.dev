---
title: 'Guide : MongoDB et Zod avec Nuxt 3'
description: "Une approche sans ORM pour int√©grer MongoDB dans une application Nuxt 3"
publishedAt: '2024-02-20'
icon: 'heroicons:code-bracket'
sitemap:
  lastmod: '2024-02-20'
  changefreq: monthly
  priority: 0.8
---

Bonjour √† tous,

Aujourd'hui je vais vous pr√©senter une fa√ßon de connecter votre application Nuxt √† une base de donn√©es MongoDB et √† valider les donn√©es entrantes avec Zod.
Cette technique offre une grande flexibilit√© ainsi que d'excellentes performances en se passant d'un ORM tel que Mongoose. Elle permet √©galement de d√©finir des sch√©mas de validations utilisables aussi bien cot√© client que cot√© serveur.
Dans cet article, nous utiliserons √©galement Typescript mais vous devriez pouvoir convertir le code en Javascript sans difficult√©s.

## 1. Pr√©requis
Il nous faudra d√©j√† avoir une application Nuxt 3 en place ainsi que MongoDB sur votre machine. Pour en cr√©er une application, je vous invite √† suivre le [guide officiel](https://nuxt.com/docs/getting-started/installation).

Nous allons ensuite installer les d√©pendances n√©cessaires :
```bash
pnpm add mongodb zod
```

## 2. Connexion √† la base de donn√©es
Pour initialiser notre client MongoDB, nous allons cr√©er une classe `DBClient` :
```ts [~/db/client.ts]
import { MongoClient } from 'mongodb'

export class DBClient {
  static mongoClient: MongoClient

  static async connect(url: string) {
    if (this.mongoClient) return

    this.mongoClient = new MongoClient(url)
    await this.mongoClient.connect()
  }

  static get db() {
    if (!this.mongoClient) throw new Error('Mongo client not connected')
    return this.mongoClient.db()
  }
}
```

Il faut ensuite initialiser la connexion au d√©marrage de l'application. Pour √ßa nous allons utiliser un [plugin nitro](https://nitro.unjs.io/guide/plugins).

Attention : bien que le plugin d√©crit ci-dessous est asynchrone, il faut garder en t√™te que nitro n'en tiendra pas compte √† l'initialisation. Ce qui veut dire que si vous ajoutez un autre plugin apr√®s celui-ci, le client Mongo ne sera pas n√©cessairement connect√©.
```ts [~/server/plugins/db.ts]
import { DBClient } from '~/db/client'

export default defineNitroPlugin(async () => {
  const config = useRuntimeConfig()
  try {
    await DBClient.connect(config.mongoUrl)

    console.log('[DB] connection established.')
  }
  catch (err) {
    console.error('[DB] connection failed.', err)
  }
})
```

Comme vous pouvez le voir, ce plugin utilise une cl√© de config runtime pour l'url de la DB. Ajoutons une valeur par d√©faut √† cette config dans le fichier `nuxt.config.ts` :
```ts [~/nuxt.config.ts]
export default defineNuxtConfig({
  // ...
  runtimeConfig: {
    mongoUrl: 'mongodb://localhost:27017/demo'
  }
  // ...
})
```

Pour changer la valeur de la config, en production par exemple, nous pourrons ajouter la variable d'environment `NUXT_MONGO_URL` au fichier `.env` ou √† notre environment (cf [le guide sur les variables d'environment](https://nuxt.com/docs/guide/going-further/runtime-config#environment-variables)) :
``` [~/.env]
NUXT_MONGO_URL="mongodb://localhost:27017/production"
```

## 3. Mod√®le de donn√©es et repositories
Maintenant que notre application est pr√™te √† utiliser notre base de donn√©es MongoDB, nous pouvons d√©finir notre sch√©ma de donn√©es √† l'aide de la librairie [Zod](https://zod.dev/) :
```ts [~/db/message.schema.ts]
import { z } from 'zod'

export const message = z.object({
  username: z.string().min(3, 'Doit √™tre plus long que 3 caract√®res').max(20, 'Doit √™tre plus court que 20 caract√®res').trim(),
  content: z.string().min(1, 'Ne doit pas √™tre vide').trim(),
})
export const messageDTO = z.object({ username: message.shape.username, content: message.shape.content }).strict()
export type MessageDTO = z.infer<typeof messageDTO>
```
Ce fichier exporte :
- le sch√©ma qu'on utilisera pour d√©finir un mod√®le de donn√©es.
- un sch√©ma `Data Transfer Object` qui sera utilis√© pour la validation des donn√©es entr√©es par l'utilisateur aussi bien cot√© client que cot√© serveur.
- Le type de notre `DTO` pour le typage Typescript.

Nous allons ensuite cr√©er une classe de base pour d√©finir les comportement commun √† tous nos mod√®les :
```ts [~/db/base.repo.ts]
import { ObjectId } from 'mongodb'
import { DBClient } from './client'

export interface BaseModel {
  _id: ObjectId
  id: string
  createdAt: Date
  updatedAt: Date
}

export class BaseRepository<Model extends BaseModel> {
  private collectionName: string

  constructor(collectionName: string) {
    this.collectionName = collectionName
  }

  get collection() {
    return DBClient.db.collection<Model>(this.collectionName)
  }

  initDocument(object: any) {
    const now = new Date()
    const _id = new ObjectId()

    return {
      _id,
      id: _id.toString(),
      createdAt: now,
      ...object,
    }
  }
}
```
Cette classe permet :
- d'acc√®der √† la collection MongoDB correspondante avec le getter `.collection`.
- d'initialiser un nouveau document √† partir de l'objet qu'on passe en param√®tre de la fonction `.initDocument`.

On peut dor√©navant cr√©er une classe pour encapluser la logique m√©tier de nos messages. Dans cet exemple, nous aurons besoin de seulement 2 fonctions : une pour valider/cr√©er un nouveau message, et une autre pour r√©cup√©rer les 10 derniers messages pour les afficher dans l'application :
```ts [~/db/message.repo.ts]
import type { z } from 'zod'
import { type MessageDTO, type message, messageDTO } from './message.schema'
import { type BaseModel, BaseRepository } from './base.repo'

export type MessageModel = z.infer<typeof message> & BaseModel

export class MessageRepository extends BaseRepository<MessageModel> {
  constructor() {
    super('messages')
  }

  async create(dto: MessageDTO) {
    const candidate = messageDTO.parse(dto)
    const document = this.initDocument(candidate)
    await this.collection.insertOne(document)
    return document as MessageModel
  }

  async getRecent() {
    return await this.collection.find({}, { sort: { createdAt: -1 }, limit: 10 }).toArray()
  }
}
```

## 4. Formulaire et validation cot√© client
Voyons √† pr√©sent comment profiter de notre sch√©ma pour valider notre formulaire. Pour faire simple, nous allons tout impl√©menter dans `~/app.vue` :
```vue [~/app.vue]
<script setup lang="ts">
import { messageDTO } from './db/message.schema';

const formData = reactive({ username: '', content: '' })
const formErrors = reactive({ username: '', content: '' })
function onSubmit() {
  const result = messageDTO.safeParse(formData)
  if (!result.success) {
    const formattedError = result.error.format()
    formErrors.username = formattedError.username?._errors[0] || ''
    formErrors.content = formattedError.content?._errors[0] || ''

    return
  }
}
</script>

<template>
  <div>
    <form @submit.prevent="onSubmit">
      <div>
        <input v-model="formData.username" type="text" placeholder="Votre nom" />
        <p>{{ formErrors.username }}</p>
      </div>
      <div>
        <textarea v-model="formData.content" placeholder="Votre message" />
        <p>{{ formErrors.content }}</p>
      </div>
      <button type="submit">Envoyer</button>
    </form>
  </div>
</template>
```
Nous avons 2 objets r√©actifs : un pour stocker les valeurs des champs de notre formulaire, et un pour stocker les erreurs de validations.
Puis nous avons une fonction `onSubmit` qui va valider notre formulaire et qui l'enverra plus tard √† notre API. Si des erreurs sont d√©tect√©s, elles seront ajout√©s √† l'objet `formErrors`. Pour aller plus loin on pourrait utiliser soit une librairie externe capable d'utiliser un sch√©ma zod (ex: [Nuxt UI](https://ui.nuxt.com/components/form#zod), [@formkit/zod](https://formkit.com/fr/plugins/zod)), soit impl√©menter un composable pour extraire la logique de validation et la rendre r√©utilisable mais restons simple pour ce guide !

## 5. API et validation cot√© serveur
√Ä pr√©sent nous allons ajouter une route d'API qui sera responsable de la validation et de la cr√©ation des nouveaux messages :
```ts [~/server/api/messages/index.post.ts]
import { ZodError } from 'zod'
import { MessageRepository } from '~/db/message.repo'

export default defineEventHandler(async (event) => {
  try {
    const body = await readBody<{ username: string, content: string }>(event)
    const repo = new MessageRepository()
    const message = await repo.create(body)
    return { message }
  }
  catch (error) {
    if (error instanceof ZodError) {
      const formatedError = (error as ZodError).format()
      sendError(event, createError({ status: 422, data: formatedError }))
    }
    else {
      sendError(event, createError('Une erreur est survenue'))
    }
  }
})
```
En premier lieu, on parse le contenu du body de la requ√™te, puis on le passe √† la fonction `create` d'une instance de notre classe `MessageRepository`. Si le message est valide, on le renvoit en r√©ponse. Si non, l'erreur sera intercept√©e, format√©e puis renvoy√© au client.

Maintenant nous allons mettre √† jour notre client pour utiliser notre nouvelle route:
```ts [~/app.vue]
function onSubmit() {
  // le reste du code
  $fetch('/api/messages', {
    method: 'POST',
    body: formData,
  })
    .then(() => {
      formErrors.username = ''
      formErrors.content = ''
      formData.username = ''
      formData.content = ''
    }).catch((err) => {
      if (err.data) {
        formErrors.username = err.data.data.username?._errors[0] || ''
        formErrors.content = err.data.data.content?._errors[0] || ''
      }
      else {
        console.error(err)
      }
    })
}
```
Si la requ√™te r√©ussis, on r√©initialise les erreurs et on vide les champs du formulaire. Si non, on r√©cup√®re le contenu de l'erreur et on affiche les messages de validations dans leurs champs respectifs.

## 6. R√©cup√©ration de nos messages
Nous avons d√©j√† couvert l'essentiel de cette architecture, mais pour finaliser cette d√©mo, nous allons ajouter une route d'API pour r√©cuperer les messages :
```ts [~/server/api/messages/index.ts]
import { MessageRepository } from "~/db/message.repo"

export default defineEventHandler(async () => {
  const repo = new MessageRepository()
  const messages = await repo.getRecent()

  return { messages }
})
```

Et maintenant on met √† jour le client :
```vue [~/app.vue]
<script setup lang="ts">
// ...
const { data, refresh } = await useFetch('/api/messages')
// ...

function onSubmit() {
  // ...

  $fetch('/api/messages', {
    method: 'POST',
    body: formData,
  })
    .then(() => {
      formData.username = ''
      formData.content = ''
      refresh()
    })
    // ...
}
</script>

<template>
  <div>
    <!-- ... -->
    <div v-for="message in data.messages">
      <p>{{ message.username }} :<br>{{ message.content }}</p>
    </div>
  </div>
</template>

```

## Conclusion
Dans ce guide nous avons vu comment int√©grer une base de donn√©es MongoDB √† une application Nuxt 3 ainsi que de g√©rer nos sch√©mas et nos validations √† l'aide de Zod.
L'avantage de cette architecture est qu'elle permet de facilement encapsuler notre logique m√©tier dans des "repositories" et avoir ainsi un code tr√®s expressif. Nous avons √©galement une grande maitrise des interractions avec la base de donn√©es sans la lourdeur et la complexit√© que peuvent apporter certains ORM. Aussi, nous avons √† notre disposition des sch√©mas de donn√©es que nous utilisons pour valider et typer nos donn√©es sans g√©n√©ration de code.

Vous pouvez √©galement retrouver le projet de d√©mo sur [GitHub](https://github.com/pedraal/nuxt-mongodb-zod-demo).

Je vous proposerai bien de partager vos impressions dans l'espace commentaire, mais il n'y en a pas (encore) üôÉ, donc je vais ouvrir les discussions sur le repo si certaines choses vous tiennes √† coeur !
